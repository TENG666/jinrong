# **第三章.基本概念**

标签（空格分隔）： 未分类


---
##3.1 语法##
##3.2 关键字和保留字##
##3.3 变量##
##3.4 数据类型##
Safari 5 及之前版本、Chrome7及之前版本，在对正则表达式调用typeof操作符时会返回**"function"**，而其他浏览器在这种情况下会返回**"object"**。

实际上，undefined 值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回 true： 

    alert(null == undefined); //true 
    
    
##3.5操作符##
只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以
体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。

如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN；
如果是 Infinity 被 Infinity 除，则结果是 NaN；
如果是 Infinity 与 0 相乘，则结果是 NaN；
如果是 Infinity 被 Infinity 除，则结果是 NaN；
如果是 Infinity 加-Infinity，则结果是 NaN；
如果是 Infinity 减 Infinity，则结果是 NaN；
如果是-Infinity 减-Infinity，则结果是 NaN；
如果是 Infinity 减-Infinity，则结果是 Infinity；
如果是-Infinity 减 Infinity，则结果是-Infinity；

**总结一句话**: 只要结果值不是明显的Infinity或者-Infinity，就是NAN

因为 null 和 undefined没有toString()方法，所以String()函数就返回了这两个值的字面量。

var result = "a" < 3; // false，因为"a"被转换成了 NaN
由于字母"a"不能转换成合理的数值，因此就被转换成了 NaN。根据规则，任何操作数与NaN进行关系比较，结果都是false。于是，就出现了下面这个有意思的现象，按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与 NaN 进行比较时，这两个比较操作的结果都返回了 false。

    var result1 = NaN < 3; //false
    var result2 = NaN >= 3; //false
    

null == 0 false 

记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返
回 false，因为它们是不同类型的值。

##3.6语句

    var iNum = 0;
    for (var i=1; i<10; i++) {
    if (i % 5 == 0) {
        continue;
    }
    iNum++;
    }
    alert(iNum);	//输出 "8"
    
这里，alert 将显示 "8"，即执行循环的次数。可能执行的循环总数为 9，
不过当 i 的值为 5 时，将执行 continue 语句，会使循环跳过表达式 iNum++，返回循环开头。



##3.7函数##

javascript传递参数如果是object的话，是按值传递

*参考博客：JS是按值传递还是按引用传递? | BOSN.ME*
http://bosn.me/js/js-call-by-sharing/

按值传递 VS. 按引用传递
按值传递(call by value)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。

按引用传递(call by reference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。

按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。

按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。

探究JS值的传递方式
JS的基本类型，是按值传递的。

    var a = 1;
    function foo(x) {
       x = 2;
    }
    foo(a);
    console.log(a); // 仍为1, 未受x = 2赋值所影响
再来看对象：

    var obj = {x : 1};
    function foo(o) {
        o.x = 3;
    }
    foo(obj);
    console.log(obj.x); // 3, 被修改了!
说明o和obj是同一个对象，o不是obj的副本。所以不是按值传递。 但这样是否说明JS的对象是按引用传递的呢？我们再看下面的例子：

    var obj = {x : 1};
    function foo(o) {
       o = 100;
    }
    foo(obj);
    console.log(obj.x); // 仍然是1, obj并未被修改为100.
如果是按引用传递，修改形参o的值，应该影响到实参才对。但这里修改o的值并未影响obj。 因此JS中的对象并不是按引用传递。那么究竟对象的值在JS中如何传递的呢？

按共享传递 call by sharing
准确的说，JS中的基本类型按值传递，对象类型按共享传递的(call by sharing，也叫按对象传递、按对象共享传递)。最早由Barbara Liskov. 在1974年的GLU语言中提出。该求值策略被用于Python、Java、Ruby、JS等多种语言。

该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。如下面例子中，不可以通过修改形参o的值，来修改obj的值。

    var obj = {x : 1};
    function foo(o) {
        o = 100;
    }
    foo(obj);
    console.log(obj.x); // 仍然是1, obj并未被修改为100.
然而，虽然引用是副本，引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参的属性值。

    var obj = {x : 1};
    function foo(o) {
    o.x = 3;
        }
    foo(obj);
    console.log(obj.x); // 3, 被修改了!
对于对象类型，由于对象是可变(mutable)的，修改对象本身会影响到共享这个对象的引用和引用副本。而对于基本类型，由于它们都是不可变的(immutable)，按共享传递与按值传递(call by value)没有任何区别，所以说JS基本类型既符合按值传递，也符合按共享传递。

    var a = 1; // 1是number类型，不可变 var b = a; b = 6;

据按共享传递的求值策略，a和b是两个不同的引用(b是a的引用副本)，但引用相同的值。由于这里的基本类型数字1不可变，所以这里说按值传递、按共享传递没有任何区别。


*知乎*
作者：苏墨橘
链接：https://www.zhihu.com/question/27114726/answer/35481766。

  数据类型在 javascript 中数据类型可以分为两类：原始数据类型值 primitive type，比如Undefined,Null,Boolean,Number,String。
  引用类型值，也就是对象类型 Object type,比如Object,Array,Function,Date等。
  声明变量时不同的内存分配。
  原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。
  引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。不同的内存分配机制也带来了不同的访问机制在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的。
  复制变量时的不同
  原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已
  引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）
  **参数传递的不同首先我们应该明确一点**：ECMAScript中所有函数的参数都是按值来传递的。但是为什么涉及到原始类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。 （我对比了一下，这里和复制变量时遵循的机制完全一样的嘛，你可以简单地理解为传递参数的时候，就是把实参复制给形参的过程）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。或许我这么说了以后你对书上的例子还是有点不太理解，那么请看图吧：<img src="https://pic2.zhimg.com/50/33472bcc2789b7d071f119169b7d6e20_hd.jpg" class="content_image">所以，如果是按引用传递的话，是把第二格中的内容（也就是变量本身）整个传递进去（就不会有第四格的存在了）。但事实是变量把它里面的值传递（复制）给了参数，让这个参数也指向原对象。因此如果在函数内部给这个参数赋值另一个对象时，这个参数就会更改它的值为新对象的内存地址指向新的对象，但此时原来的变量仍然指向原来的对象，这时候他们是相互独立的；但如果这个参数是改变对象内部的属性的话，这个改变会体现在外部，因为他们共同指向的这个对象被修改了呀！来看下面这个例子吧：（传说中的call by sharing）
    
    var obj1 = {
    value:'111'
    };
    var obj2 = {
    value:'222'
    };
 
    function changeStuff(obj){
    obj.value = '333';
    obj = obj2;
    return obj.value;
    }
    var foo = changeStuff(obj1);
 
    console.log(foo);// '222' 参数obj指向了新的对象obj2
    console.log(obj1.value);//'333'
code里的注释太小看不清，我移到这里来：/* obj1仍然指向原来的对象,之所以value改变了,
 *是因为changeStuff里的第一条语句，这个时候obj是指向obj1的 .
 *再啰嗦一句，如果是按引用传递的话，这个时候obj1.value应该是等于'222'的
*/
